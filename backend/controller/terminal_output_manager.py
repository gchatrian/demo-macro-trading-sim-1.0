"""
Terminal Output Manager
Handles formatted output to the terminal for the simulation.
"""

from typing import Optional, Dict, Any
from datetime import datetime
from colorama import Fore, Back, Style, init

# Initialize colorama for Windows support
init(autoreset=True)


class TerminalOutputManager:
    """
    Manages formatted output to the terminal.
    Provides methods for displaying narratives, logs, and headers.
    """
    
    def __init__(self, use_colors: bool = True):
        """
        Initialize the Terminal Output Manager.
        
        Args:
            use_colors: Whether to use colored output (default True)
        """
        self.use_colors = use_colors
        self.narrative_count = 0
    
    def _color(self, text: str, color: str) -> str:
        """
        Apply color to text if colors are enabled.
        
        Args:
            text: Text to color
            color: Colorama color constant
            
        Returns:
            Colored text or plain text
        """
        if self.use_colors:
            return f"{color}{text}{Style.RESET_ALL}"
        return text
    
    def print_header(
        self, 
        title: str, 
        sim_datetime: Optional[datetime] = None,
        width: int = 80
    ):
        """
        Print a formatted header.
        
        Args:
            title: Header title
            sim_datetime: Optional simulated datetime to display
            width: Width of the header box
        """
        separator = "=" * width
        
        print(f"\n{self._color(separator, Fore.CYAN)}")
        
        if sim_datetime:
            time_str = sim_datetime.strftime('%Y-%m-%d %H:%M:%S')
            header_text = f"{title} | {time_str}"
        else:
            header_text = title
        
        # Center the text
        padding = (width - len(header_text)) // 2
        centered = " " * padding + header_text
        
        print(self._color(centered, Fore.CYAN + Style.BRIGHT))
        print(f"{self._color(separator, Fore.CYAN)}\n")
    
    def print_narrative(
        self,
        narrative_type: str,
        content: str,
        event_info: Optional[Dict[str, Any]] = None,
        sim_datetime: Optional[datetime] = None
    ):
        """
        Print a narrative generated by the LLM.
        
        Args:
            narrative_type: Type of narrative ('pre_release', 'post_release', 'event')
            content: The narrative text
            event_info: Optional dictionary with event details
            sim_datetime: Optional simulated datetime
        """
        self.narrative_count += 1
        
        # Determine header based on type
        if narrative_type == 'pre_release':
            header = "üìä PRE-RELEASE ANALYSIS"
            color = Fore.YELLOW
        elif narrative_type == 'post_release':
            header = "üìà POST-RELEASE REACTION"
            color = Fore.GREEN
        elif narrative_type == 'event':
            header = "üåç MACRO EVENT COMMENTARY"
            color = Fore.MAGENTA
        else:
            header = "üì∞ NEWS"
            color = Fore.WHITE
        
        # Print header
        self.print_header(header, sim_datetime, width=80)
        
        # Print event info if provided
        if event_info:
            if 'name' in event_info:  # Release
                info_text = f"Event: {event_info['name']}"
                if 'consensus' in event_info:
                    info_text += f" | Consensus: {event_info['consensus']}"
                if 'actual' in event_info:
                    info_text += f" | Actual: {event_info['actual']}"
            elif 'headline' in event_info:  # Macro event
                info_text = f"Event: {event_info['headline']}"
            else:
                info_text = None
            
            if info_text:
                print(self._color(f"‚ÑπÔ∏è  {info_text}", Fore.CYAN))
                print()
        
        # Print the narrative content
        # Wrap text for better readability
        wrapped_content = self._wrap_text(content, width=78)
        print(self._color(wrapped_content, color))
        
        # Print footer
        print(f"\n{self._color('‚îÄ' * 80, Fore.CYAN)}\n")
    
    def print_system_log(
        self, 
        message: str, 
        level: str = "INFO",
        sim_datetime: Optional[datetime] = None
    ):
        """
        Print a system log message.
        
        Args:
            message: Log message
            level: Log level ('INFO', 'SUCCESS', 'WARNING', 'ERROR')
            sim_datetime: Optional simulated datetime
        """
        # Color based on level
        if level == "SUCCESS":
            symbol = "‚úì"
            color = Fore.GREEN
        elif level == "WARNING":
            symbol = "‚ö†"
            color = Fore.YELLOW
        elif level == "ERROR":
            symbol = "‚úó"
            color = Fore.RED
        else:  # INFO
            symbol = "‚Ñπ"
            color = Fore.CYAN
        
        # Format timestamp
        if sim_datetime:
            time_str = sim_datetime.strftime('%H:%M:%S')
            prefix = f"[{time_str}]"
        else:
            prefix = ""
        
        # Print log
        log_line = f"{prefix} {symbol} {message}"
        print(self._color(log_line, color))
    
    def print_macro_state(
        self,
        growth: float,
        inflation: float,
        volatility: float,
        regime: Optional[str] = None,
        sim_datetime: Optional[datetime] = None
    ):
        """
        Print current macro-economic state.
        
        Args:
            growth: Growth value
            inflation: Inflation value
            volatility: Volatility value
            regime: Optional regime description
            sim_datetime: Optional simulated datetime
        """
        print(f"\n{self._color('‚îå' + '‚îÄ' * 78 + '‚îê', Fore.BLUE)}")
        
        title = "üìä MACRO-ECONOMIC STATE"
        if sim_datetime:
            time_str = sim_datetime.strftime('%Y-%m-%d %H:%M')
            title += f" | {time_str}"
        
        print(self._color(f"‚îÇ {title:<77}‚îÇ", Fore.BLUE + Style.BRIGHT))
        print(self._color('‚îú' + '‚îÄ' * 78 + '‚î§', Fore.BLUE))
        
        # Print variables
        print(self._color(f"‚îÇ Growth:     {growth:>6.2f}%{' ' * 60}‚îÇ", Fore.GREEN))
        print(self._color(f"‚îÇ Inflation:  {inflation:>6.2f}%{' ' * 60}‚îÇ", Fore.YELLOW))
        print(self._color(f"‚îÇ Volatility: {volatility:>6.2f}{' ' * 61}‚îÇ", Fore.RED))
        
        if regime:
            print(self._color('‚îú' + '‚îÄ' * 78 + '‚î§', Fore.BLUE))
            regime_text = f"Regime: {regime}"
            print(self._color(f"‚îÇ {regime_text:<77}‚îÇ", Fore.CYAN))
        
        print(self._color('‚îî' + '‚îÄ' * 78 + '‚îò', Fore.BLUE))
        print()
    
    def print_progress(
        self,
        current: int,
        total: int,
        message: Optional[str] = None
    ):
        """
        Print a progress indicator.
        
        Args:
            current: Current progress value
            total: Total value
            message: Optional message to display
        """
        percentage = (current / total * 100) if total > 0 else 0
        bar_length = 50
        filled = int(bar_length * current / total) if total > 0 else 0
        bar = '‚ñà' * filled + '‚ñë' * (bar_length - filled)
        
        progress_text = f"Progress: [{bar}] {percentage:.1f}% ({current}/{total})"
        
        if message:
            progress_text += f" - {message}"
        
        print(self._color(progress_text, Fore.CYAN))
    
    def print_welcome(self):
        """Print welcome banner"""
        banner = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                            ‚ïë
‚ïë                  MACRO TRADING SIMULATOR - DEMO v1.0                       ‚ïë
‚ïë                                                                            ‚ïë
‚ïë              AI-Driven Economic Narrative Generation System                ‚ïë
‚ïë                                                                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
        print(self._color(banner, Fore.CYAN + Style.BRIGHT))
        
        print(self._color("Scenario:", Fore.YELLOW + Style.BRIGHT))
        print("  Goldilocks ‚Üí Boom (Q1-Q3 2025)")
        print("  Driven by: AI Breakthrough, Accommodating Fed, Fiscal Stimulus\n")
        
        print(self._color("Controls:", Fore.YELLOW + Style.BRIGHT))
        print("  Press CTRL+C to stop the simulation\n")
    
    def print_goodbye(self):
        """Print goodbye message"""
        print(f"\n{self._color('='*80, Fore.CYAN)}")
        print(self._color("Simulation Ended", Fore.CYAN + Style.BRIGHT))
        print(f"{self._color('='*80, Fore.CYAN)}")
        print(f"\nTotal narratives generated: {self.narrative_count}")
        print("\nThank you for using the Macro Trading Simulator!")
    
    def _wrap_text(self, text: str, width: int = 78) -> str:
        """
        Wrap text to specified width while preserving paragraphs.
        
        Args:
            text: Text to wrap
            width: Maximum line width
            
        Returns:
            Wrapped text
        """
        paragraphs = text.split('\n')
        wrapped_paragraphs = []
        
        for para in paragraphs:
            if not para.strip():
                wrapped_paragraphs.append('')
                continue
            
            words = para.split()
            lines = []
            current_line = []
            current_length = 0
            
            for word in words:
                word_length = len(word)
                
                if current_length + word_length + len(current_line) <= width:
                    current_line.append(word)
                    current_length += word_length
                else:
                    if current_line:
                        lines.append(' '.join(current_line))
                    current_line = [word]
                    current_length = word_length
            
            if current_line:
                lines.append(' '.join(current_line))
            
            wrapped_paragraphs.append('\n'.join(lines))
        
        return '\n\n'.join(wrapped_paragraphs)
    
    def clear_screen(self):
        """Clear the terminal screen (optional, use with caution)"""
        import os
        os.system('cls' if os.name == 'nt' else 'clear')
